#BlueJ class context
comment0.params=inStream
comment0.target=Parser(java.io.InputStream)
comment0.text=\n\ Constructor\ for\ objects\ of\ class\ Parser\n\ @param\ inStream\ \ \ \ \ \ the\ input\ stream\ to\ be\ read,\ tokenized,\ and\ evaluated\n
comment1.params=expected
comment1.target=void\ eat(java.lang.String)
comment1.text=\n\ Method\ eat\ consumes\ the\ next\ token\ of\ input\ in\ the\ input\ stream.\n\ @param\ expected\ \ \ \ \ \ the\ string\ expected\ to\ be\ eaten.\n\ @throws\ Exception\ \ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n
comment10.params=
comment10.target=ast.Statement\ parseStatement()
comment10.text=\n\ Method\ parseStatement\ reads\ the\ input\ token\ and\ begins\ evaluating\ a\n\ statement\ in\ the\ pascal\ language.\ A\ statement\ starts\ either\ with\ a\ print\n\ command\ (WRITELN),\ a\ begin\ block\ command\ (BEGIN),\ a\ variable/procedure\ declaration,\n\ an\ if\ statement\ (IF),\ or\ a\ while\ statement\ (WHILE\ [cond]\ DO\ [xyz]).\n\ \n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n\ @return\ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ parsed\ statement\n
comment11.params=
comment11.target=ast.Program\ parseProgram()
comment11.text=\n\ Evaluates\ the\ entire\ AST\ of\ the\ program.\n\ @return\ \ \ \ \ \ an\ AST\ describing\ the\ entire\ program\n
comment12.params=
comment12.target=boolean\ hasNext()
comment12.text=\n\ Method\ hasNext\ determines\ whether\ or\ not\ there\ are\ still\ statements\ to\ be\ parsed.\n\ @return\ \ \ \ \ \ true\ if\ there\ are\ still\ statements\ to\ be\ parsed\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ false\ otherwise\n
comment2.params=
comment2.target=ast.Expression\ parseNumber()
comment2.text=\n\ Method\ parseNumber\ reads\ an\ integer\ from\ the\ current\ token\ and\ consumes\ it,\n\ returning\ an\ ast.Number\ object\ containing\ integer\ read.\n\ @precondition\ \ \ \ \ \ \ \ the\ current\ token\ is\ a\ number\n\ @return\ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ ast.Number\ object\ containing\ the\ value\ read\ from\ the\ current\ token\n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n
comment3.params=
comment3.target=ast.Expression\ parseIdentifier()
comment3.text=\n\ Method\ parseIdentifier\ reads\ a\ variable\ from\ the\ current\ token\ and\ consumes\ it,\n\ returning\ a\ Variable\ object\ containing\ the\ variable\ name\n\ @precondition\ \ \ \ \ \ \ \ the\ current\ token\ is\ a\ previously\ declared\ variable\n\ @return\ \ \ \ \ \ \ \ \ \ \ \ \ \ a\ Variable\ object\ storing\ the\ name\ of\ the\ variable\n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n
comment4.params=
comment4.target=ast.Expression\ parseFactor()
comment4.text=\n\ Method\ parseFactor\ reads\ a\ factor\ starting\ from\ the\ current\ token.\ If\ an\ open\ parenthesis\ is\n\ encountered,\ the\ parser\ object\ begins\ parsing\ a\ new\ statement,\ the\ value\ of\ which\n\ it\ will\ return.\ If\ a\ minus\ sign\ is\ encountered,\ the\ parser\ begins\ parsing\ another\ factor\ and\n\ returns\ a\ BinOp\ object\ evaluating\ to\ 0-[value],\ equivalent\ to\ the\ negative\ of\ that\ value.\n\ Otherwise,\ it\ checks\ if\ currentToken\ is\ a\ variable\ or\ procedure\ and\ parses\ accordingly.\n\ \n\ @precondition\ \ \ \ \ \ \ \ all\ tokens\ are\ valid\ tokens\ in\ the\ Pascal\ language\n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n\ @return\ \ \ \ \ \ \ \ \ \ \ \ \ \ an\ Expression\ consisting\ of\ an\ AST\ equivalent\ to\ the\ parsed\ factor\n
comment5.params=
comment5.target=ast.Expression\ parseTerm()
comment5.text=\n\ Method\ parseTerm\ reads\ a\ term,\ defined\ as\ a\ series\ of\ factors\ multiplied\ together\ or\n\ divided\ by\ one\ another.\ parseTerm\ first\ reads\ a\ factor\ starting\ from\ the\ current\ token,\ then\n\ reads\ *\ or\ /\ indicating\ whether\ to\ multiply\ or\ divide,\ grouping\ all\ previous\ multiplications\n\ and\ divisions\ into\ the\ same\ expression\ to\ maintain\ associativity\n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n\ @return\ \ \ \ \ \ a\ BinOp\ consisting\ of\ two\ expressions\ and\ either\ "*"\ or\ "/"\n
comment6.params=
comment6.target=ast.Expression\ parseExpression()
comment6.text=\n\ Method\ parseExpression\ reads\ an\ expression,\ defined\ as\ a\ series\ of\ terms\ added\ together\ or\n\ subtracted.\ parseExpression\ first\ reads\ a\ term\ starting\ from\ the\ current\ token,\ then\n\ reads\ +\ or\ -\ indicating\ whether\ to\ add\ or\ subtract,\ grouping\ all\ previous\ additions\n\ and\ subtractions\ into\ the\ same\ expression\ to\ maintain\ associativity\n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n\ @return\ \ \ \ \ \ a\ BinOp\ consisting\ of\ two\ expressions\ and\ either\ "+"\ or\ "-"\n
comment7.params=sts
comment7.target=void\ parseStatements(java.util.ArrayList)
comment7.text=\n\ Method\ parseStatements\ parses\ a\ series\ of\ statements,\ storing\ them\ in\ an\ ArrayList.\n\ Starting\ from\ the\ current\ token,\ it\ parses\ the\ statement\ and\ terminates\ if\ END\ is\ reached.\n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n\ @param\ sts\ \ \ \ \ \ \ \ \ \ \ the\ list\ of\ statements\ in\ which\ to\ store\ each\ parsed\ statement\n
comment8.params=str
comment8.target=boolean\ isIdentifier(java.lang.String)
comment8.text=\n\ Tests\ whether\ or\ not\ an\ input\ string\ is\ an\ identifier\ of\ the\ form\ \n\ [A-Z,\ a-z][A-Z,\ a-z,\ 0-9]*\n\ @param\ str\ \ \ \ \ \ \ the\ String\ to\ be\ tested\n\ @return\ \ \ \ \ \ \ \ \ \ true\ if\ str\ is\ a\ valid\ identifier\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ false\ otherwise\n
comment9.params=
comment9.target=ast.Condition\ parseCondition()
comment9.text=\n\ Helper\ method\ parseCondition\ parses\ a\ conditional\ statement\ consisting\ of\ two\ expressions\n\ separated\ by\ a\ relative\ operator\ of\ type\ {<,\ >,\ \=,\ <>,\ <\=,\ >\=},\ returning\ a\ Condition\n\ object\ containing\ the\ two\ expressions\ and\ the\ relative\ operator.\n\ @throws\ Exception\ \ \ \ if\ the\ expected\ String\ does\ not\ match\ the\ consumed\ token\n\ @return\ \ \ \ \ \ \ \ \ \ a\ Condition\ object\ containing\ the\ two\ expressions\ and\ the\ relative\ operator\n
numComments=13
